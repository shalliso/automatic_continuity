import Mathlib

open Filter Set Topology
variable {X : Type*} [TopologicalSpace X]

/-- A set is residual iff it includes an intersection over Nat of dense open sets. -/
theorem mem_residual_iff_iInter_nat {s : Set X} :
    s ‚àà residual X ‚Üî
      ‚àÉ (f : ‚Ñï ‚Üí Set X), (‚àÄ n, IsOpen (f n)) ‚àß (‚àÄ n, Dense (f n)) ‚àß ‚ãÇ n, f n ‚äÜ s := by
  rw [mem_residual_iff]
  constructor
  intro ‚ü®S, h_open, h_dense, h_ctbl, h_s‚ü©
  by_cases h_S : S.Nonempty
  . obtain ‚ü®f, h_f‚ü© := Countable.exists_surjective h_S h_ctbl
    let f' : ‚Ñï ‚Üí Set X := fun n ‚Ü¶ (f n : Set X)
    have f_surj : range f' = S := by
      ext x
      constructor
      intro h
      obtain ‚ü®n, hn‚ü© := h
      rw [‚Üê hn]
      exact Subtype.coe_prop (f n)

      intro h
      simp [f']
      have hxS : x ‚àà S := h
      obtain ‚ü®n, hn‚ü© := h_f ‚ü®x, hxS‚ü©
      use n
      rw [hn]
    use f'
    constructor
    intro n
    have : f' n ‚àà S := by exact Subtype.coe_prop (f n)
    exact h_open (f' n) this

    constructor
    intro n
    have : f' n ‚àà S := by exact Subtype.coe_prop (f n)
    exact h_dense (f' n) this

    have asdf : ‚ãÇ n, f' n = ‚ãÇ‚ÇÄ S := by
      simp [f']
      ext x
      exact
        Iff.symm
          (Eq.to_iff (congrFun (congrArg Membership.mem (congrArg sInter (id (Eq.symm f_surj)))) x))
    rw [asdf]
    assumption

  rw [not_nonempty_iff_eq_empty] at h_S
  rw [h_S] at h_s
  simp at h_s
  set g := Function.const ‚Ñï s
  use g
  simp [g, h_s]
  . intro ‚ü®f, h_open, h_dense, h_inter‚ü©
    use range f
    refine ‚ü®by simpa, by simpa, countable_range f, by simpa‚ü©

/-- A countable union of meagre sets is meagre. -/
lemma isMeagre_iUnion' {Œπ : Type*} [Countable Œπ] {f : Œπ ‚Üí Set X} (hs : ‚àÄ i, IsMeagre (f i))
    : IsMeagre (‚ãÉ i, f i) := by
  rw [IsMeagre, compl_iUnion]
  exact countable_iInter_mem.mpr hs

/-
lemma isMeagre_bUnion {Œπ : Type*} {S : Set Œπ} (hS: S.Countable) {f : ‚àÄ i ‚àà S, Set X}
  (hs : ‚àÄ i ‚àà S, IsMeagre (f i ‚Äπ_‚Ä∫)) : IsMeagre (‚ãÇ i, ‚ãÇ hi : i ‚àà S, f i ‚Äπ_‚Ä∫) := by

  sorry
-/

variable {G : Type*} [Group G] [MulAction G X] [ContinuousConstSMul G X]

open Pointwise

theorem residual_smul' {A : Set X} {g : G} : A ‚àà residual X ‚Üí g ‚Ä¢ A ‚àà residual X := by
  intro h
  obtain ‚ü®S, h_open, h_dense, h_ctbl, h_inter‚ü© := mem_residual_iff.mp h
  set S' := g ‚Ä¢ S
  refine mem_residual_iff.mpr ‚ü®S', ?_, ?_, ?_, ?_‚ü©

  simp [S']
  intro U hU
  have h1 : g‚Åª¬π ‚Ä¢ U ‚àà S := by exact mem_smul_set_iff_inv_smul_mem.mp hU
  have h2 : U = g ‚Ä¢ (g‚Åª¬π ‚Ä¢ U) := by exact Eq.symm (smul_inv_smul g U)
  have h3 := h_open (g‚Åª¬π ‚Ä¢ U) h1
  have h4 : IsOpen (g ‚Ä¢ (g‚Åª¬π ‚Ä¢ U)) := by exact IsOpen.smul (h_open (g‚Åª¬π ‚Ä¢ U) h1) g
  rw [‚Üêh2] at h4
  assumption

  simp [S']
  intro U hU
  have h1 : g‚Åª¬π ‚Ä¢ U ‚àà S := by exact mem_smul_set_iff_inv_smul_mem.mp hU
  have h2 : U = g ‚Ä¢ (g‚Åª¬π ‚Ä¢ U) := by exact Eq.symm (smul_inv_smul g U)
  have h3 := h_dense (g‚Åª¬π ‚Ä¢ U) h1
  have h4 : Dense (g ‚Ä¢ (g‚Åª¬π ‚Ä¢ U)) := by exact Dense.smul g (h_dense (g‚Åª¬π ‚Ä¢ U) h1)
  rw [‚Üêh2] at h4
  assumption

  rcases Set.eq_empty_or_nonempty S with rfl|hS
  . have : S' = ‚àÖ := by
      exact smul_set_empty
    rwa [this]

  obtain ‚ü®f, hf‚ü© : ‚àÉ (f : ‚Ñï ‚Üí Set X), S = range f := Countable.exists_eq_range h_ctbl hS
  set h := fun (n : ‚Ñï) ‚Ü¶ (g ‚Ä¢ f n)
  rw [countable_iff_exists_subset_range]
  use h
  intro s hs
  obtain ‚ü®s', hs1, hs2‚ü© := hs
  simp at hs2
  rw [hf] at hs1
  obtain ‚ü®n, hfn‚ü© := hs1
  use n
  simp [h, hfn, hs2]


  have : ‚ãÇ‚ÇÄ S' = g ‚Ä¢ (‚ãÇ‚ÇÄ S) := by
    simp [S']
    ext x
    constructor

    intro h
    simp [HSMul.hSMul, SMul.smul]
    use g‚Åª¬π ‚Ä¢ x
    constructor
    intro t ht
    have : g ‚Ä¢ t ‚àà g ‚Ä¢ S := by exact smul_mem_smul_set ht
    have : x ‚àà g ‚Ä¢ t := by exact h (g ‚Ä¢ t) this
    (expose_names; exact mem_smul_set_iff_inv_smul_mem.mp (h (g ‚Ä¢ t) this_1))

    exact smul_inv_smul g x

    intro h
    intro t ht
    have h453 : g‚Åª¬π ‚Ä¢ t ‚àà S := by exact mem_smul_set_iff_inv_smul_mem.mp ht
    simp [HSMul.hSMul, SMul.smul] at h
    obtain ‚ü®x_1, hx_1t, hx2‚ü© := h
    rw [‚Üêhx2]
    have h12 : x_1 ‚àà g‚Åª¬π ‚Ä¢ t := by exact hx_1t (g‚Åª¬π ‚Ä¢ t) h453
    have : g ‚Ä¢ x_1 ‚àà t := by exact mem_inv_smul_set_iff.mp (hx_1t (g‚Åª¬π ‚Ä¢ t) h453)
    exact this

  intro x hx
  rw [this] at hx
  have : g ‚Ä¢ ‚ãÇ‚ÇÄ S ‚äÜ g ‚Ä¢ A := by exact smul_set_mono h_inter
  exact this hx



theorem residual_smul {A : Set X} {g : G} : A ‚àà residual X ‚Üí g ‚Ä¢ A ‚àà residual X := by
  intro h
  obtain ‚ü®f, h_open, h_dense, h_inter‚ü© := mem_residual_iff_iInter_nat.mp h
  set f' := g ‚Ä¢ f
  refine mem_residual_iff_iInter_nat.mpr ‚ü®
    f',
    fun n ‚Ü¶ IsOpen.smul (h_open n) g,
    fun n ‚Ü¶ Dense.smul g (h_dense n),
    ?_‚ü©
  dsimp [f']
  rw [‚Üêsmul_set_iInter]
  exact smul_set_mono h_inter

theorem isMeagre_smul {A : Set X} {g : G} : IsMeagre A ‚Üí IsMeagre (g ‚Ä¢ A) := by
  dsimp [IsMeagre]
  rw [‚Üêsmul_set_compl]
  exact residual_smul

/-- A union of two meagre sets is meagre. -/
lemma isMeagre_union {s t : Set X} (hs : IsMeagre s) (ht : IsMeagre t)
    : IsMeagre (s ‚à™ t) := by
  rw [IsMeagre, compl_union]
  exact inter_mem hs ht



theorem isGŒ¥_smul (v : G) (A : Set X) (hA : IsGŒ¥ A) : IsGŒ¥ (v ‚Ä¢ A) := by
  rw [isGŒ¥_iff_eq_iInter_nat] at hA ‚ä¢
  obtain ‚ü®f, hctbl, hunionA‚ü© := hA

  set g := v ‚Ä¢ f
  refine ‚ü®g, ?_, ?_‚ü©
  . intro n
    simp [g]
    exact IsOpen.smul (hctbl n) v
  rw [hunionA]
  rw [Set.smul_set_iInter]
  simp [g]

open symmDiff

/-- A set is Baire measurable if and only if it differs from some open set by a meager set. -/
theorem BaireMeasurableSet.iff_meagre_symmDiff_isOpen {s : Set X} :
    BaireMeasurableSet s ‚Üî ‚àÉ u : Set X, (IsOpen u) ‚àß (IsMeagre (symmDiff s u)) := by
  constructor
  intro h
  obtain ‚ü®u, hu, hus‚ü© := BaireMeasurableSet.iff_residualEq_isOpen.mp h
  use u
  constructor
  use hu
  dsimp [IsMeagre]

  simp [EventuallyEq, Filter.Eventually] at hus
  have : {x | s x ‚Üî u x} = (s ‚àÜ u)·∂ú := by
    ext x
    simp [bihimp]
    tauto
  rwa [‚Üêthis]

  intro ‚ü®u, hopen, hmeagre‚ü©
  rw [BaireMeasurableSet.iff_residualEq_isOpen]
  refine ‚ü®u, hopen, ?_‚ü©
  simp [EventuallyEq, Filter.Eventually]
  simp only [IsMeagre] at hmeagre
  have : {x | s x ‚Üî u x} = (s ‚àÜ u)·∂ú := by
    ext x
    simp [bihimp]
    tauto
  rwa [this]



/-- A residual set is nonempty.
    Put this in Topology/Baire/Lemmas.lean
-/
theorem nonempty_of_residual [Nonempty X] [BaireSpace X] {s : Set X} : s ‚àà residual X ‚Üí s.Nonempty := by
  exact (fun h ‚Ü¶ (dense_of_mem_residual h).nonempty)

theorem empty_IsMeagre [BaireSpace X] : IsMeagre (‚àÖ : Set X) := by
  by_contra h
  simp only [IsMeagre, compl_empty, univ_mem, not_true_eq_false] at h




variable [TopologicalSpace G] [IsTopologicalGroup G] [BaireSpace G] [MeasurableSpace G] [BorelSpace G]


example {A : Set G} (hA : A ‚àà residual G) : A * A‚Åª¬π = ‚ä§ := by
  ext g
  constructor
  . intro _
    trivial
  intro _
  have : g ‚Ä¢ A ‚àà residual G := by exact residual_smul hA
  have : A ‚à© (g ‚Ä¢ A) ‚àà residual G := Filter.inter_mem hA this
  have hy : ‚àÉ y, y ‚àà A ‚à© (g ‚Ä¢ A) := nonempty_of_residual this
  obtain ‚ü®y, hy1, hy2‚ü© := hy
  have hy22 : g‚Åª¬π * y ‚àà A := by
    simpa [HSMul.hSMul, SMul.smul] using hy2
  have hy222 : (g‚Åª¬π * y)‚Åª¬π ‚àà A‚Åª¬π := by simpa using hy22
  have h1: y * (g‚Åª¬π * y)‚Åª¬π ‚àà A * A‚Åª¬π := by exact Set.mul_mem_mul hy1 hy222
  simpa using h1

example {U : Set G} {g : G} (hgU : g ‚àà U) (hU_open : IsOpen U)
    : ‚àÉ V : Set G, (IsOpen V) ‚àß (1 ‚àà V) ‚àß ({g} * (V * V‚Åª¬π) ‚äÜ U) := by
  -- Since multiplication and inversion are continuous, and U is open and contains g,
    -- there exists an open neighborhood V of 1 such that g * (V * V‚Åª¬π) ‚äÜ U.
  let m := fun (‚ü®x, y‚ü© : G √ó G) ‚Ü¶ g * x * y‚Åª¬π
  have hm : Continuous m := by
    continuity
  have h1 : m ‚ü®1, 1‚ü© ‚àà U := by simpa [m]
  have h2 : IsOpen (m ‚Åª¬π' U) := by exact hm.isOpen_preimage U hU_open
  rw [isOpen_prod_iff] at h2
  specialize h2 1 1 h1
  obtain ‚ü®V1, V2, hV1open, hV2open, h1V1, h1V2, hV1V2‚ü© := h2
  let V := V1 ‚à© V2
  have hV2invopen : IsOpen V2‚Åª¬π := by exact IsOpen.inv hV2open
  have hV2inv1 : 1 ‚àà V2‚Åª¬π := by simpa
  use V
  refine ‚ü®IsOpen.inter hV1open hV2open, Set.mem_inter h1V1 h1V2, ?_‚ü©
  have h11 : V ‚äÜ V1 := by exact Set.inter_subset_left
  have h12 : V ‚äÜ V2 := by exact Set.inter_subset_right
  intro x hx
  obtain ‚ü®x1, hx1, hx2, hx3, hx4‚ü© := hx
  simp at hx4
  simp at hx1
  rw [hx1] at hx4
  obtain ‚ü®v1, v2, v3, v4, v5‚ü© := hx3
  simp at v5
  rw [‚Üêv5] at hx4
  rw [‚Üêhx4]
  have : ‚ü®v1, v3‚Åª¬π‚ü© ‚àà V1 √óÀ¢ V2 := by exact Set.mk_mem_prod (h11 v2) (h12 v4)
  have : ‚ü®v1, v3‚Åª¬π‚ü© ‚àà m ‚Åª¬π' U := by exact hV1V2 this
  have : m ‚ü®v1, v3‚Åª¬π‚ü© ‚àà U := by exact this
  simp [m] at this
  rw [‚Üêmul_assoc]
  exact this

lemma mImg {g : G} (V1 V2 : Set G) :
    let m := fun p : G √ó G ‚Ü¶ g * (p.1 * p.2‚Åª¬π)
    m '' V1 √óÀ¢ V2 = g ‚Ä¢ (V1 * V2‚Åª¬π) := by
  ext x
  constructor

  intro h
  simp at h
  obtain ‚ü®a, b, ‚ü®ha, hb‚ü©, himg‚ü© := h
  simp [HSMul.hSMul, SMul.smul, HMul.hMul, Mul.mul]
  rw [‚Üê himg]
  use a
  use ha
  use b‚Åª¬π
  constructor
  simpa
  rfl

  intro h
  simp
  simp [HSMul.hSMul, SMul.smul, HMul.hMul, Mul.mul] at h
  obtain ‚ü®a, ha, b, hb, hab‚ü© := h
  use a
  use b‚Åª¬π
  use ‚ü®ha, hb‚ü©
  simpa


lemma small_nbhd {U : Set G} {g : G} (hgU : U ‚àà ùìù g)
    : ‚àÉ V ‚àà ùìù 1, g ‚Ä¢ (V * V‚Åª¬π) ‚äÜ U := by
  set m := fun p : G √ó G => g * (p.1 * p.2‚Åª¬π)
  have h_cont' : Continuous m := by continuity
  have h_cont : ContinuousAt m ‚ü®1, 1‚ü© := by exact Continuous.continuousAt h_cont'
  have h_image : m ‚ü®1, 1‚ü© = g := by simp [m]
  simp only [ContinuousAt, h_image] at h_cont

  have t := h_cont hgU
  simp at t
  obtain ‚ü®V1, hV1, V2, hV2, hV_sub‚ü© :=  mem_nhds_prod_iff.mp t
  use V1 ‚à© V2
  refine ‚ü®Filter.inter_mem hV1 hV2, ?_‚ü©
  have hmV_sub : m '' V1 √óÀ¢ V2 ‚äÜ U := by simpa
  have hmV_def: m '' V1 √óÀ¢ V2 = g ‚Ä¢ (V1 * V2‚Åª¬π) := by exact mImg V1 V2
  have h100 : (V1 ‚à© V2 * (V1 ‚à© V2)‚Åª¬π) ‚äÜ V1 * V2‚Åª¬π := by
    exact
      Set.mul_subset_mul Set.inter_subset_left
      (by simp only [Set.inter_inv, Set.inter_subset_right])
  have : g ‚Ä¢ (V1 ‚à© V2 * (V1 ‚à© V2)‚Åª¬π) ‚äÜ g ‚Ä¢ (V1 * V2‚Åª¬π) := by exact smul_set_mono h100
  rw [‚ÜêhmV_def] at this
  exact fun ‚¶Éa‚¶Ñ a_1 ‚Ü¶ hmV_sub (this a_1)

lemma asdf234 {s1 s2 t1 t2 : Set G} : (s1 ‚à© s2) ‚àÜ (t1 ‚à© t2) ‚äÜ (s1 ‚àÜ t1) ‚à™ (s2 ‚àÜ t2) := by
  simp [symmDiff] at *
  constructor
  intro x hx
  simp at hx
  obtain ‚ü®‚ü®h1, h2‚ü©, h3‚ü© := hx
  by_cases h4: x ‚àà t1
  right
  left
  exact mem_diff_of_mem h2 (h3 h4)
  left
  left
  exact mem_diff_of_mem h1 h4

  intro x hx
  simp at hx
  obtain ‚ü®‚ü®h1, h2‚ü©, h3‚ü© := hx
  by_cases h4: x ‚àà s1
  right
  right
  exact mem_diff_of_mem h2 (h3 h4)
  left
  right
  exact mem_diff_of_mem h1 h4


theorem pettis {A : Set G} (hBM : BaireMeasurableSet A) (hA : ¬¨ IsMeagre A)
    : A * A‚Åª¬π ‚àà nhds 1 := by
  rw [BaireMeasurableSet.iff_meagre_symmDiff_isOpen] at hBM
  obtain ‚ü®U, h_open, h_meager_diff‚ü© := hBM

  have hU_nonempty : U.Nonempty := by
    by_contra hUempty
    simp at hUempty
    have : U = ‚àÖ := by exact Set.not_nonempty_iff_eq_empty.mp hUempty
    rw [this] at h_open
    simp [this, symmDiff] at h_meager_diff
    contradiction

  obtain ‚ü®g, hgU‚ü© := hU_nonempty
  have h5 : U ‚àà ùìù g := by exact IsOpen.mem_nhds h_open hgU
  have h57 : IsOpen U‚Åª¬π := by exact IsOpen.inv h_open
  have h435 : g‚Åª¬π ‚àà U‚Åª¬π := by exact Set.inv_mem_inv.mpr hgU
  have h567 : U‚Åª¬π ‚àà ùìù g‚Åª¬π := by
    exact IsOpen.mem_nhds h57 h435
  have ‚ü®V, hV1, hVU‚ü© := small_nbhd h567
  refine Filter.mem_of_superset hV1 ?_
  intro v hvV
  have h54 : 1 ‚àà V‚Åª¬π := by
    simp
    exact mem_of_mem_nhds hV1
  have h2345 : v ‚àà V * V‚Åª¬π := by
    exact ‚ü®v, hvV, 1, h54, MulOneClass.mul_one v‚ü©
  have h234324 : g‚Åª¬π ‚Ä¢ v ‚àà g‚Åª¬π ‚Ä¢ (V * V‚Åª¬π) := by
    exact smul_mem_smul_set h2345
  have h23456 : g‚Åª¬π ‚Ä¢ v ‚àà U‚Åª¬π := by
    exact hVU h234324
  have h234567 : v‚Åª¬π * g ‚àà U := by
    simpa using h23456
  have h2345678 : g ‚àà v ‚Ä¢ U := by
    exact mem_smul_set_iff_inv_smul_mem.mpr h234567
  have h99 : IsMeagre ((v ‚Ä¢ A) ‚àÜ (v ‚Ä¢ U)) := by
    rw [‚Üêsmul_set_symmDiff]
    exact isMeagre_smul h_meager_diff
  have h101 : IsMeagre ((A ‚àÜ U) ‚à™ ((v ‚Ä¢ A) ‚àÜ (v ‚Ä¢ U))) := by
    exact isMeagre_union h_meager_diff h99
  have h102 : ((A ‚à© v ‚Ä¢ A) ‚àÜ (U ‚à© v ‚Ä¢ U)) ‚äÜ ((A ‚àÜ U) ‚à™ ((v ‚Ä¢ A) ‚àÜ (v ‚Ä¢ U))) := by
    exact asdf234
  have h100 : IsMeagre ((A ‚à© v ‚Ä¢ A) ‚àÜ (U ‚à© v ‚Ä¢ U)) := by
    exact IsMeagre.mono h101 h102
  have h200 : (U ‚à© v ‚Ä¢ U).Nonempty := by
    use g
    exact mem_inter hgU h2345678
  have h2034 : IsOpen (v ‚Ä¢ U) := by exact IsOpen.smul h_open v
  have h201 : IsOpen (U ‚à© v ‚Ä¢ U) := by
    exact IsOpen.inter h_open h2034
  have h204 : IsClosed (U ‚à© v ‚Ä¢ U)·∂ú := by
    exact isClosed_compl_iff.mpr h201
  have h205 : closure (U ‚à© v ‚Ä¢ U)·∂ú = (U ‚à© v ‚Ä¢ U)·∂ú := by
    exact closure_eq_iff_isClosed.mpr h204
  have h206 : closure (U ‚à© v ‚Ä¢ U)·∂ú ‚â† univ := by
    simp
    exact nonempty_iff_ne_empty.mp h200
  have h202 : ¬¨ Dense (U ‚à© v ‚Ä¢ U)·∂ú := by
    by_contra h
    rw [dense_iff_closure_eq] at h
    contradiction
  have h101 : (A ‚à© v ‚Ä¢ A).Nonempty := by
    by_contra h_empty
    have : (A ‚à© v ‚Ä¢ A) = ‚àÖ := by exact not_nonempty_iff_eq_empty.mp h_empty
    rw [this] at h100
    simp [symmDiff] at h100
    dsimp [IsMeagre] at h100
    apply dense_of_mem_residual at h100
    contradiction
  obtain ‚ü®g, hgA, hgAv‚ü© := h101
  simp at hgAv
  have : g‚Åª¬π * v ‚àà A‚Åª¬π := by
    obtain ‚ü®a, ha, ha2‚ü© := hgAv
    simp at ha2
    rw [‚Üê ha2]
    simpa
  have : g * (g‚Åª¬π * v) ‚àà A * A‚Åª¬π := by
    exact Set.mul_mem_mul hgA this
  simpa using this

theorem pettis' {A : Set G} (hBM : BaireMeasurableSet A) (hA : ¬¨ IsMeagre A)
    : A‚Åª¬π * A ‚àà nhds 1 := by
  have h0 : BaireMeasurableSet A‚Åª¬π := by
    set m : G ‚Üí G := fun g ‚Ü¶ g‚Åª¬π
    have h1 : Continuous m := by exact continuous_inv
    have h2 : IsOpenMap m := by exact isOpenMap_inv G
    have h3 : BaireMeasurableSet (m ‚Åª¬π' A) := by exact BaireMeasurableSet.preimage h1 h2 hBM
    simp [m] at h3
    assumption
  have h1 : ¬¨ (IsMeagre A‚Åª¬π) := by
    by_contra h
    set m : G ‚Üí G := fun g ‚Ü¶ g‚Åª¬π
    have h1 : Continuous m := by exact continuous_inv
    have h2 : IsOpenMap m := by exact isOpenMap_inv G
    have h3 : IsMeagre (m ‚Åª¬π' A‚Åª¬π) := by exact IsMeagre.preimage_of_isOpenMap h1 h2 h
    simp [m] at h3
    contradiction
  have h2 : A‚Åª¬π‚Åª¬π = A := by exact DivisionMonoid.inv_inv A
  nth_rw 2 [‚Üê h2]
  exact pettis h0 h1

variable {H: Type*} [Group H] [TopologicalSpace H] [IsTopologicalGroup H] [BaireSpace H]
  [MeasurableSpace H] [BorelSpace H]


lemma lem3 {U : Set H} (hU : U ‚àà ùìù 1)
  : ‚àÉ V ‚àà ùìù 1, V‚Åª¬π * V ‚äÜ U := by
    set m : H √ó H ‚Üí H := fun p ‚Ü¶ p.1‚Åª¬π * p.2
    have h_cont' : Continuous m := by continuity
    have h_cont : ContinuousAt m ‚ü®1, 1‚ü© := by exact Continuous.continuousAt h_cont'
    have h_image : m ‚ü®1, 1‚ü© = 1 := by simp [m]
    simp only [ContinuousAt, h_image] at h_cont

    have t := h_cont hU
    simp at t
    obtain ‚ü®V1, hV1, V2, hV2, hV_sub‚ü© :=  mem_nhds_prod_iff.mp t
    use V1 ‚à© V2
    refine ‚ü®Filter.inter_mem hV1 hV2, ?_‚ü©
    have hmV_sub : m '' V1 √óÀ¢ V2 ‚äÜ U := by simpa
    have hmV_def: m '' V1 √óÀ¢ V2 = V1‚Åª¬π * V2 := by
      simp [m]

      ext x
      constructor

      intro h
      simp at h
      obtain ‚ü®a, b, ‚ü®ha, hb‚ü©, himg‚ü© := h
      simp [HSMul.hSMul, SMul.smul, HMul.hMul, Mul.mul]
      rw [‚Üê himg]
      use a‚Åª¬π
      constructor
      simpa
      use b
      constructor
      assumption
      rfl

      intro h
      simp
      simp [HSMul.hSMul, SMul.smul, HMul.hMul, Mul.mul] at h
      obtain ‚ü®a, ha, b, hb, hab‚ü© := h
      use a‚Åª¬π
      use b
      use ‚ü®ha, hb‚ü©
      simpa
    have h100 : ((V1 ‚à© V2)‚Åª¬π * (V1 ‚à© V2)) ‚äÜ V1‚Åª¬π * V2 := by
      apply Set.mul_subset_mul
      simp
      simp
    rw [‚ÜêhmV_def] at h100

    exact fun ‚¶Éa‚¶Ñ a_1 ‚Ü¶ hmV_sub (h100 a_1)

lemma lem3' {U : Set H} (hU : U ‚àà ùìù 1)
    : ‚àÉ V, IsOpen V ‚àß 1 ‚àà V ‚àß V‚Åª¬π * V ‚äÜ U := by
  obtain ‚ü®V, h_1_V, hVU‚ü© := lem3 hU
  obtain ‚ü®W, hWV, hW_open, hW_1‚ü© := eventually_nhds_iff.mp h_1_V
  use W
  refine ‚ü®hW_open, hW_1, ?_‚ü©
  have : W‚Åª¬π ‚äÜ V‚Åª¬π := by exact fun ‚¶Éa‚¶Ñ ‚Ü¶ hWV a‚Åª¬π
  have : W‚Åª¬π * W ‚äÜ V‚Åª¬π * V := by exact mul_subset_mul this hWV
  exact fun ‚¶Éa‚¶Ñ a_1 ‚Ü¶ hVU (this a_1)

lemma lem4 (D : Set H) (h_D_dense : Dense D) (V : Set H) (h_V_open : IsOpen V)
  (h_V_nonempty : V.Nonempty)
  : ‚ãÉ d ‚àà D, d ‚Ä¢ V = ‚ä§ := by
    ext x
    constructor
    . intro h
      simp at h
      obtain ‚ü®i, hi‚ü© := h
      trivial
    intro h
    obtain ‚ü®v, hv‚ü© := h_V_nonempty
    have V_inv_open : IsOpen V‚Åª¬π := by exact IsOpen.inv h_V_open
    have h_V_open' : IsOpen (x ‚Ä¢ V‚Åª¬π) := by exact IsOpen.smul V_inv_open x
    have h_nonempty : (x ‚Ä¢ V‚Åª¬π).Nonempty := by
      use x ‚Ä¢ v‚Åª¬π
      simpa [HSMul.hSMul, SMul.smul]
    have h1 : ‚àÉ d ‚àà D, d ‚àà x ‚Ä¢ V‚Åª¬π := by
      exact Dense.exists_mem_open h_D_dense h_V_open' h_nonempty
    obtain ‚ü®d, hdD, hdxV‚ü© := h1
    have h2 : x ‚àà d ‚Ä¢ V := by
      simp at hdxV
      assumption
    simp
    exact ‚ü®d, hdD, h2‚ü©


open TopologicalSpace

variable [SeparableSpace H]

theorem automatic_continuity {œÜ : G ‚Üí* H} (h: Measurable œÜ)
  : Continuous œÜ := by
  constructor
  intro U hU
  have h0 : MeasurableSet U := by exact IsOpen.measurableSet hU
  set preU := œÜ ‚Åª¬π' U
  have h10 : MeasurableSet preU := by
    exact h h0
  rw [isOpen_iff_mem_nhds]
  intro g hg
  have h_Im_g_in_U: œÜ g ‚àà U := by exact hg
  have h_1_in_ginvU : 1 ‚àà (œÜ g)‚Åª¬π ‚Ä¢ U := by
    use œÜ g
    refine ‚ü®h_Im_g_in_U, ?_‚ü©
    simp
  have h_ginvU_open : IsOpen ((œÜ g)‚Åª¬π ‚Ä¢ U) := by
    exact IsOpen.smul hU (œÜ g)‚Åª¬π

  have : (œÜ g)‚Åª¬π ‚Ä¢ U ‚àà ùìù 1 := by exact IsOpen.mem_nhds h_ginvU_open h_1_in_ginvU
  have ‚ü®V, h_V_open, h_1_in_V, h_V_U‚ü© := lem3' this

  have h_V_nonempty : V.Nonempty := by exact Set.nonempty_of_mem h_1_in_V

  have ‚ü®D, hD_countable, hD_dense‚ü© := exists_countable_dense H

  have h1 : ‚ãÉ h ‚àà D, h ‚Ä¢ V = ‚ä§ := by exact lem4 D hD_dense V h_V_open h_V_nonempty
  have h11 : œÜ‚Åª¬π' (‚ãÉ h ‚àà D, h ‚Ä¢ V) = ‚ãÉ h ‚àà D, œÜ‚Åª¬π' (h ‚Ä¢ V) := by
    exact preimage_iUnion‚ÇÇ
  have h2 : ‚ãÉ h ‚àà D, œÜ‚Åª¬π' (h ‚Ä¢ V) = ‚ä§ := by
    rw [‚Üêh11, h1]
    rfl
  have h100 : ¬¨ (IsMeagre (‚ä§ : Set G)) := by
    by_contra h
    simp [IsMeagre] at h
    apply nonempty_of_residual at h
    simp at h
  have h101 : ‚àÉ d ‚àà D, ¬¨ IsMeagre (œÜ‚Åª¬π' (d ‚Ä¢ V)) := by
    by_contra h_contra
    simp at h_contra
    have : Countable ‚ÜëD := by exact hD_countable
    have : IsMeagre (‚ãÉ h ‚àà D, œÜ‚Åª¬π' (h ‚Ä¢ V)) := by
      rw [biUnion_eq_iUnion]
      apply isMeagre_iUnion'
      simpa
    rw [h2] at this
    contradiction
  obtain ‚ü®d, hd, hnonmeagre‚ü© := h101
  set A := œÜ‚Åª¬π' (d ‚Ä¢ V)
  have h38 : IsOpen (d ‚Ä¢ V) := by exact IsOpen.smul h_V_open d
  have h83 : MeasurableSet (d ‚Ä¢ V) := by exact IsOpen.measurableSet h38
  have h385 : MeasurableSet A := by exact h h83
  have h39 : BaireMeasurableSet A := by
    exact MeasurableSet.baireMeasurableSet h385
  have h4 : A‚Åª¬π * A ‚àà nhds 1 := by exact pettis' h39 hnonmeagre
  have h222: g ‚Ä¢ (A‚Åª¬π * A) ‚àà nhds g := by exact smul_mem_nhds_self.mpr h4
  have h23 : œÜ '' (g ‚Ä¢ (A‚Åª¬π * A)) ‚äÜ U := by
    intro x hx
    simp at hx
    obtain ‚ü®x_1, hx_1, hx_2‚ü© := hx
    simp [HSMul.hSMul, SMul.smul] at hx_1
    obtain ‚ü®a_1, ha_1, a_2, ha_2, ha_x‚ü© := hx_1
    simp at ha_x
    rw [‚Üê hx_2]
    have h143 : x_1 = g * (a_1 * a_2) := by exact eq_mul_of_inv_mul_eq (id (Eq.symm ha_x))
    rw [h143]
    simp
    have h123 : œÜ a_2 ‚àà d ‚Ä¢ V := by exact ha_2
    have h12340 : œÜ '' A ‚äÜ d ‚Ä¢ V := by
      dsimp [A]
      exact image_preimage_subset (‚áëœÜ) (d ‚Ä¢ V)
    have h1232 : œÜ a_1 ‚àà (œÜ '' A)‚Åª¬π := by
      simp
      use a_1‚Åª¬π
      constructor
      assumption
      simp
    have h124 : œÜ a_1 ‚àà (d ‚Ä¢ V)‚Åª¬π := by
      exact h12340 h1232
    have h2323 : œÜ a_1 * œÜ a_2 ‚àà V‚Åª¬π * V := by
      obtain ‚ü®v_1, h_v_1, h_v_12‚ü© := h123
      obtain ‚ü®v_2, h_v_2, h_v_22‚ü© := h124
      simp at h_v_12 h_v_22
      have h_v_222 : (d * v_2)‚Åª¬π = œÜ a_1 := by exact inv_eq_iff_eq_inv.mpr h_v_22
      rw [‚Üêh_v_12, ‚Üêh_v_222]
      have h_v_2111 : v_2‚Åª¬π ‚àà V‚Åª¬π := by exact Set.inv_mem_inv.mpr h_v_2
      use v_2‚Åª¬π
      constructor
      exact h_v_2111
      use v_1
      constructor
      exact h_v_1
      simp
      group

    have h_V_U_2 : (œÜ g) ‚Ä¢ (V‚Åª¬π * V) ‚äÜ U := by
      exact Set.smul_set_subset_iff_subset_inv_smul_set.mpr h_V_U
    have h3213 : œÜ g * (œÜ a_1 * œÜ a_2) ‚àà œÜ g ‚Ä¢ (V‚Åª¬π * V) := by
      exact mem_leftCoset (œÜ g) h2323
    exact h_V_U_2 h3213
  have h234 : g ‚Ä¢ (A‚Åª¬π * A) ‚äÜ preU := by
    simp at h23
    simpa [preU]
  exact mem_of_superset h222 h234

#print axioms automatic_continuity
